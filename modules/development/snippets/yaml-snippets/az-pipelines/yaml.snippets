snippet az-pipeline-starter "Complete Azure DevOps YAML Pipeline with Build, Test, and Deploy stages"
trigger:
  branches:
    include:
    - main
    - develop
    - release/*
  paths:
    exclude:
    - README.md
    - '**/*.md'

pr:
  branches:
    include:
    - main
    - develop
    - feature/*
    - bugfix/*
    - hotfix/*

pool:
  vmImage: 'ubuntu-latest'

variables:
  - name: buildConfiguration
    value: 'Release'
  - name: buildPlatform
    value: 'anycpu'
  - group: 'GlobalVariables'

stages:
  - stage: Build
    displayName: 'Build Stage'
    jobs:
    - job: Build
      displayName: 'Build Application'
      steps:
      - task: UseDotNet@2
        displayName: 'Use .NET SDK'
        inputs:
          version: '6.x'

      - task: DotNetCoreCLI@2
        displayName: 'Restore NuGet packages'
        inputs:
          command: 'restore'
          projects: '**/*.csproj'

      - task: DotNetCoreCLI@2
        displayName: 'Build solution'
        inputs:
          command: 'build'
          projects: '**/*.csproj'
          arguments: '--configuration $(buildConfiguration) --no-restore'

      - task: DotNetCoreCLI@2
        displayName: 'Run tests'
        inputs:
          command: 'test'
          projects: '**/*Tests.csproj'
          arguments: '--configuration $(buildConfiguration) --no-build --verbosity normal'

      - task: DotNetCoreCLI@2
        displayName: 'Publish application'
        inputs:
          command: 'publish'
          publishWebProjects: true
          arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory) --no-build'

      - task: PublishBuildArtifacts@1
        displayName: 'Publish artifacts'
        inputs:
          PathtoPublish: '$(Build.ArtifactStagingDirectory)'
          ArtifactName: 'drop'

  - stage: DeployToDev
    displayName: 'Deploy to Development'
    dependsOn: Build
    condition: succeeded()
    jobs:
    - deployment: DeployDev
      displayName: 'Deploy to Development'
      environment: 'Development'
      strategy:
        runOnce:
          deploy:
            steps:
            - download: current
              artifact: drop
            - task: AzureWebApp@1
              displayName: 'Deploy to Azure Web App'
              inputs:
                azureSubscription: '$(azureServiceConnection)'
                appName: '$(webAppNameDev)'
                package: '$(Pipeline.Workspace)/drop/**/*.zip'

  - stage: DeployToProd
    displayName: 'Deploy to Production'
    dependsOn: DeployToDev
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
    - deployment: DeployProd
      displayName: 'Deploy to Production'
      environment: 'Production'
      strategy:
        runOnce:
          deploy:
            steps:
            - download: current
              artifact: drop
            - task: AzureWebApp@1
              displayName: 'Deploy to Azure Web App'
              inputs:
                azureSubscription: '$(azureServiceConnection)'
                appName: '$(webAppNameProd)'
                package: '$(Pipeline.Workspace)/drop/**/*.zip'
$0
endsnippet

snippet az-docker-pipeline "Docker build and push pipeline for Azure Container Registry"
trigger:
  branches:
    include:
    - main
    - develop

variables:
  - name: imageRepository
    value: '$(Build.Repository.Name).toLower()'
  - name: dockerfilePath
    value: '**/Dockerfile'
  - name: tag
    value: '$(Build.BuildId)'

stages:
  - stage: BuildAndPush
    displayName: 'Build and Push Docker Image'
    jobs:
    - job: Build
      displayName: 'Build Docker Image'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
      - task: Docker@2
        displayName: 'Login to ACR'
        inputs:
          command: 'login'
          containerRegistry: '$(acrServiceConnection)'

      - task: Docker@2
        displayName: 'Build and Push'
        inputs:
          command: 'buildAndPush'
          repository: '$(imageRepository)'
          dockerfile: '$(dockerfilePath)'
          containerRegistry: '$(acrServiceConnection)'
          tags: |
            $(tag)
            latest

      - task: Docker@2
        displayName: 'Logout from ACR'
        inputs:
          command: 'logout'
          containerRegistry: '$(acrServiceConnection)'
$0
endsnippet

snippet az-k8s-pipeline "AKS deployment pipeline with Kubernetes manifests"
trigger:
  branches:
    include:
    - main

variables:
  - name: namespace
    value: 'default'
  - name: manifestPath
    value: 'manifests/'
  - name: imageTag
    value: '$(Build.BuildId)'

stages:
  - stage: DeployToAKS
    displayName: 'Deploy to AKS'
    jobs:
    - deployment: DeployAKS
      displayName: 'Deploy to AKS'
      environment: 'aks-$(namespace)'
      strategy:
        runOnce:
          deploy:
            steps:
            - task: KubernetesManifest@0
              displayName: 'Create imagePullSecret'
              inputs:
                action: 'createSecret'
                namespace: '$(namespace)'
                secretType: 'dockerRegistry'
                secretName: 'acr-secret'
                dockerRegistryEndpoint: '$(acrServiceConnection)'

            - task: KubernetesManifest@0
              displayName: 'Deploy to AKS'
              inputs:
                action: 'deploy'
                namespace: '$(namespace)'
                manifests: |
                  $(manifestPath)/deployment.yaml
                  $(manifestPath)/service.yaml
                  $(manifestPath)/ingress.yaml
                imagePullSecrets: 'acr-secret'
                containers: '$(acrRegistry)/$(imageRepository):$(imageTag)'

            - task: Kubernetes@1
              displayName: 'Check deployment status'
              inputs:
                connectionType: 'Kubernetes Service Connection'
                kubernetesServiceEndpoint: '$(aksServiceConnection)'
                namespace: '$(namespace)'
                command: 'rollout'
                arguments: 'status deployment/$(deploymentName)'
$0
endsnippet

snippet az-multi-container "Multi-container application pipeline with Docker Compose"
trigger:
  branches:
    include:
    - main

variables:
  - name: dockerComposeFile
    value: '**/docker-compose.yml'
  - name: tag
    value: '$(Build.BuildId)'

stages:
  - stage: BuildAndPushContainers
    displayName: 'Build and Push Containers'
    jobs:
    - job: BuildPushFrontend
      displayName: 'Build and Push Frontend'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
      - task: Docker@2
        displayName: 'Build Frontend'
        inputs:
          command: 'buildAndPush'
          repository: '$(frontendImageName)'
          dockerfile: '$(frontendDockerfilePath)'
          containerRegistry: '$(acrServiceConnection)'
          tags: '$(tag)'

    - job: BuildPushBackend
      displayName: 'Build and Push Backend'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
      - task: Docker@2
        displayName: 'Build Backend'
        inputs:
          command: 'buildAndPush'
          repository: '$(backendImageName)'
          dockerfile: '$(backendDockerfilePath)'
          containerRegistry: '$(acrServiceConnection)'
          tags: '$(tag)'

  - stage: DeployWithCompose
    displayName: 'Deploy with Docker Compose'
    dependsOn: BuildAndPushContainers
    jobs:
    - deployment: DeployCompose
      displayName: 'Docker Compose Deploy'
      environment: 'docker-compose'
      strategy:
        runOnce:
          deploy:
            steps:
            - task: DockerCompose@0
              displayName: 'Run Docker Compose'
              inputs:
                containerregistrytype: 'Azure Container Registry'
                azureSubscription: '$(azureServiceConnection)'
                azureContainerRegistry: '$(acrRegistry)'
                dockerComposeFile: '$(dockerComposeFile)'
                action: 'Run a Docker Compose command'
                additionalDockerComposeFiles: 'docker-compose.override.yml'
                dockerComposeCommand: 'up -d'
$0
endsnippet

snippet az-functions-pipeline "Azure Functions CI/CD pipeline"
trigger:
  branches:
    include:
    - main

variables:
  - name: functionAppName
    value: 'myfunctionapp-$(Build.BuildId)'
  - name: functionAppPath
    value: '$(System.DefaultWorkingDirectory)/MyFunctionApp'

stages:
  - stage: BuildAndDeployFunctions
    displayName: 'Build and Deploy Azure Functions'
    jobs:
    - job: BuildFunctions
      displayName: 'Build Functions'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
      - task: UseDotNet@2
        displayName: 'Use .NET SDK'
        inputs:
          version: '6.x'

      - task: DotNetCoreCLI@2
        displayName: 'Restore packages'
        inputs:
          command: 'restore'
          projects: '**/*.csproj'

      - task: DotNetCoreCLI@2
        displayName: 'Build functions'
        inputs:
          command: 'build'
          projects: '**/*.csproj'
          arguments: '--configuration Release --output $(Build.ArtifactStagingDirectory)'

      - task: ArchiveFiles@2
        displayName: 'Archive function app'
        inputs:
          rootFolderOrFile: '$(Build.ArtifactStagingDirectory)'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/functionapp.zip'

      - task: PublishBuildArtifacts@1
        displayName: 'Publish function app artifact'
        inputs:
          PathtoPublish: '$(Build.ArtifactStagingDirectory)/functionapp.zip'
          ArtifactName: 'functionapp'

    - deployment: DeployFunctions
      displayName: 'Deploy Functions'
      dependsOn: BuildFunctions
      environment: 'functions'
      strategy:
        runOnce:
          deploy:
            steps:
            - download: current
              artifact: functionapp
            - task: AzureFunctionApp@1
              displayName: 'Deploy to Azure Functions'
              inputs:
                azureSubscription: '$(azureServiceConnection)'
                appType: 'functionApp'
                appName: '$(functionAppName)'
                package: '$(Pipeline.Workspace)/functionapp/functionapp.zip'
                deploymentMethod: 'zipDeploy'
$0
endsnippet

snippet az-security-pipeline "Security scanning pipeline with various Azure security tools"
trigger: none

pr:
  branches:
    include:
    - '*'

pool:
  vmImage: 'ubuntu-latest'

variables:
  - name: skipComponentGovernanceDetection
    value: false

stages:
  - stage: SecurityScan
    displayName: 'Security Scanning'
    jobs:
    - job: SecurityChecks
      displayName: 'Run Security Checks'
      steps:
      - task: ComponentGovernanceComponentDetection@0
        displayName: 'Component Detection'
        condition: eq(variables.skipComponentGovernanceDetection, false)

      - task: CredScan@3
        displayName: 'Credential Scanner'
        inputs:
          toolMajorVersion: 'V2'
          scanFolder: '$(Build.SourcesDirectory)'
          debugMode: false

      - task: PoliCheck@1
        displayName: 'PoliCheck Scan'
        inputs:
          inputType: 'Basic'
          targetType: 'F'
          targetArgument: '$(Build.SourcesDirectory)'

      - task: SecurityAnalysis@1
        displayName: 'Security Code Analysis'
        inputs:
          enableCredScanner: true
          enableRoslynAnalyzers: true
          enablePoliCheck: true

      - task: PostAnalysis@1
        displayName: 'Post Security Analysis'
        inputs:
          AllTools: false
          CredScan: true
          PoliCheck: true
          RoslynAnalyzers: true
          ToolLogsNotFoundAction: 'Standard'
$0
endsnippet

snippet az-container-scan "Container security scanning pipeline with vulnerability checks"
trigger:
  branches:
    include:
    - main

variables:
  - name: imageName
    value: 'myapp:$(Build.BuildId)'
  - name: acrName
    value: 'myacr.azurecr.io'

stages:
  - stage: BuildAndScan
    displayName: 'Build and Security Scan'
    jobs:
    - job: BuildScanContainer
      displayName: 'Build and Scan Container'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
      - task: Docker@2
        displayName: 'Build Docker image'
        inputs:
          command: 'build'
          repository: '$(imageName)'
          dockerfile: '**/Dockerfile'
          tags: '$(Build.BuildId)'

      - task: Docker@2
        displayName: 'Scan for vulnerabilities'
        inputs:
          command: 'scan'
          dockerFile: '**/Dockerfile'
          scanType: 'advanced'
          failOnSeverity: 'high'

      - task: AzureContainerRegistry@1
        displayName: 'Push to ACR'
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
        inputs:
          command: 'push'
          azureSubscription: '$(azureServiceConnection)'
          azureContainerRegistry: '$(acrName)'
          imageName: '$(imageName)'

  - stage: DeployScannedImage
    displayName: 'Deploy Scanned Image'
    dependsOn: BuildAndScan
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
    - deployment: DeployToAKS
      displayName: 'Deploy to AKS'
      environment: 'production'
      strategy:
        runOnce:
          deploy:
            steps:
            - task: KubernetesManifest@0
              displayName: 'Deploy secured image'
              inputs:
                action: 'deploy'
                namespace: 'default'
                manifests: 'deployment.yaml'
                containers: '$(acrName)/$(imageName)'
$0
endsnippet

snippet az-bicep-pipeline "Infrastructure as Code pipeline using Bicep/ARM templates"
trigger:
  branches:
    include:
    - main
  paths:
    include:
    - 'infra/**'
    - '.pipelines/infra-pipeline.yml'

pool:
  vmImage: 'ubuntu-latest'

variables:
  - name: environment
    value: 'dev'
  - name: location
    value: 'eastus2'

stages:
  - stage: ValidateBicep
    displayName: 'Validate Bicep Templates'
    jobs:
    - job: Validate
      displayName: 'Validate Infrastructure'
      steps:
      - task: AzureCLI@2
        displayName: 'Validate Bicep files'
        inputs:
          azureSubscription: '$(azureServiceConnection)'
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            az bicep build --file infra/main.bicep
            az deployment sub validate --location $(location) --template-file infra/main.bicep --parameters infra/params/$(environment).parameters.json

  - stage: DeployInfrastructure
    displayName: 'Deploy Infrastructure'
    dependsOn: ValidateBicep
    jobs:
    - deployment: DeployResources
      displayName: 'Deploy Azure Resources'
      environment: '$(environment)'
      strategy:
        runOnce:
          deploy:
            steps:
            - task: AzureResourceManagerTemplateDeployment@3
              displayName: 'Deploy Bicep Template'
              inputs:
                deploymentScope: 'Resource Group'
                azureResourceManagerConnection: '$(azureServiceConnection)'
                subscriptionId: '$(subscriptionId)'
                action: 'Create Or Update Resource Group'
                resourceGroupName: 'rg-$(environment)-$(resourceSuffix)'
                location: '$(location)'
                templateLocation: 'Linked artifact'
                csmFile: 'infra/main.bicep'
                csmParametersFile: 'infra/params/$(environment).parameters.json'
                deploymentMode: 'Incremental'

  - stage: ConfigureResources
    displayName: 'Post-Deployment Configuration'
    dependsOn: DeployInfrastructure
    jobs:
    - job: Configuration
      displayName: 'Configure Deployed Resources'
      steps:
      - task: AzureCLI@2
        displayName: 'Run post-deployment scripts'
        inputs:
          azureSubscription: '$(azureServiceConnection)'
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            # Add post-deployment configuration here
            echo 'Infrastructure deployment completed successfully'
$0
endsnippet

snippet az-approval-pipeline "Pipeline with manual approval gates between environments"
trigger:
  branches:
    include:
    - main

variables:
  - name: environment
    value: 'dev'

stages:
  - stage: Build
    displayName: 'Build Stage'
    jobs:
    - job: BuildJob
      displayName: 'Build Application'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
      - script: echo 'Building application...'
        displayName: 'Build step'

  - stage: DeployToDev
    displayName: 'Deploy to Development'
    dependsOn: Build
    jobs:
    - deployment: DeployDev
      displayName: 'Deploy to Development'
      environment:
        name: 'Development'
        resourceType: 'VirtualMachine'
      strategy:
        runOnce:
          deploy:
            steps:
            - script: echo 'Deploying to development...'
              displayName: 'Deploy step'

  - stage: DeployToQA
    displayName: 'Deploy to QA'
    dependsOn: DeployToDev
    jobs:
    - deployment: DeployQA
      displayName: 'Deploy to QA'
      environment:
        name: 'QA'
        resourceType: 'VirtualMachine'
      strategy:
        runOnce:
          deploy:
            steps:
            - script: echo 'Deploying to QA...'
              displayName: 'Deploy step'

  - stage: ApprovalToProd
    displayName: 'Production Approval'
    dependsOn: DeployToQA
    jobs:
    - job: WaitForApproval
      displayName: 'Wait for approval'
      pool: server
      timeoutInMinutes: 4320
      steps:
      - task: ManualValidation@0
        displayName: 'Wait for production approval'
        inputs:
          instructions: 'Please approve deployment to production'
          onTimeout: 'reject'

  - stage: DeployToProd
    displayName: 'Deploy to Production'
    dependsOn: ApprovalToProd
    jobs:
    - deployment: DeployProd
      displayName: 'Deploy to Production'
      environment:
        name: 'Production'
        resourceType: 'VirtualMachine'
      strategy:
        runOnce:
          deploy:
            steps:
            - script: echo 'Deploying to production...'
              displayName: 'Deploy step'
$0
endsnippet

snippet az-testing-pipeline "Comprehensive testing pipeline with reports and code coverage"
trigger:
  branches:
    include:
    - main
    - develop

pool:
  vmImage: 'windows-latest'

variables:
  - name: testResultsFolder
    value: '$(System.DefaultWorkingDirectory)/TestResults'
  - name: codeCoverageFolder
    value: '$(System.DefaultWorkingDirectory)/CodeCoverage'

stages:
  - stage: Test
    displayName: 'Testing Stage'
    jobs:
    - job: RunTests
      displayName: 'Execute Tests'
      steps:
      - task: VSTest@2
        displayName: 'Run Unit Tests'
        inputs:
          testSelector: 'testAssemblies'
          testAssemblyVer2: |
            **/*Tests*.dll
            !**/obj/**
          searchFolder: '$(System.DefaultWorkingDirectory)'
          codeCoverageEnabled: true
          testRunTitle: 'Unit Test Run $(Build.BuildId)'

      - task: PublishTestResults@2
        displayName: 'Publish Test Results'
        inputs:
          testRunner: 'VSTest'
          testResultsFiles: '**/*.trx'
          searchFolder: '$(testResultsFolder)'
          testRunTitle: 'Test Results $(Build.BuildId)'

      - task: PublishCodeCoverageResults@1
        displayName: 'Publish Code Coverage'
        inputs:
          codeCoverageTool: 'Cobertura'
          summaryFileLocation: '$(codeCoverageFolder)/**/coverage.cobertura.xml'

      - task: SonarCloudPrepare@1
        displayName: 'Prepare SonarCloud Analysis'
        inputs:
          SonarCloud: 'SonarCloud'
          organization: '$(sonarCloudOrganization)'
          scannerMode: 'MSBuild'
          projectKey: '$(sonarCloudProjectKey)'
          projectName: '$(projectName)'

      - task: SonarCloudAnalyze@1
        displayName: 'Run SonarCloud Analysis'

      - task: SonarCloudPublish@1
        displayName: 'Publish SonarCloud Results'
$0
endsnippet

snippet az-terraform-pipeline "Terraform infrastructure pipeline with plan/apply stages"
trigger:
  branches:
    include:
    - main
  paths:
    include:
    - 'terraform/**'

pool:
  vmImage: 'ubuntu-latest'

variables:
  - name: terraformVersion
    value: '1.3.0'
  - name: environment
    value: 'dev'

stages:
  - stage: TerraformInit
    displayName: 'Terraform Init'
    jobs:
    - job: InitTerraform
      displayName: 'Initialize Terraform'
      steps:
      - task: TerraformInstaller@0
        displayName: 'Install Terraform'
        inputs:
          terraformVersion: '$(terraformVersion)'

      - task: TerraformTaskV2@2
        displayName: 'Terraform Init'
        inputs:
          provider: 'azurerm'
          command: 'init'
          workingDirectory: 'terraform/$(environment)'
          backendServiceArm: '$(azureServiceConnection)'
          backendAzureRmResourceGroupName: '$(terraformBackendRG)'
          backendAzureRmStorageAccountName: '$(terraformBackendStorage)'
          backendAzureRmContainerName: 'tfstate'
          backendAzureRmKey: '$(environment).tfstate'

  - stage: TerraformPlan
    displayName: 'Terraform Plan'
    dependsOn: TerraformInit
    jobs:
    - job: GeneratePlan
      displayName: 'Generate Terraform Plan'
      steps:
      - task: TerraformTaskV2@2
        displayName: 'Terraform Plan'
        inputs:
          provider: 'azurerm'
          command: 'plan'
          workingDirectory: 'terraform/$(environment)'
          environmentServiceNameAzureRM: '$(azureServiceConnection)'
          commandOptions: '-var-file=$(environment).tfvars -out=tfplan'

      - task: PublishBuildArtifacts@1
        displayName: 'Publish Terraform Plan'
        inputs:
          PathtoPublish: 'terraform/$(environment)/tfplan'
          ArtifactName: 'tfplan-$(environment)'

  - stage: TerraformApply
    displayName: 'Terraform Apply'
    dependsOn: TerraformPlan
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
    - job: ApplyTerraform
      displayName: 'Apply Terraform Changes'
      steps:
      - download: current
        artifact: tfplan-$(environment)

      - task: TerraformTaskV2@2
        displayName: 'Terraform Apply'
        inputs:
          provider: 'azurerm'
          command: 'apply'
          workingDirectory: 'terraform/$(environment)'
          environmentServiceNameAzureRM: '$(azureServiceConnection)'
          commandOptions: 'tfplan'
$0
endsnippet
